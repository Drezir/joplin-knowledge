id: d40683b1f086477b8310876edd84ec8f
parent_id: 1efd76e699934e0aa34d6dcb92b13797
item_type: 1
item_id: 3c61f27164c44fab8c839b967425f897
item_updated_time: 1671005574598
title_diff: "[]"
body_diff: "[{\"diffs\":[[0,\"omain.\\\n\\\n\"],[1,\"## [**REST vs. GraphQL vs. gRPC**](https://www.baeldung.com/rest-vs-graphql-vs-grpc)\\\nREST, a good fit for domains, can be easily described as a set of resources as opposed to actions. Making use of HTTP methods enables standard CRUD operations on those resources. By relying on HTTP semantics, it's intuitive to its callers, making it a good fit for public-facing interfaces. Good caching support for REST makes it suitable for APIs with stable usage patterns and geographically distributed users.\\\n\\\nGraphQL is a good fit for public APIs where multiple clients require different data sets. Therefore, GraphQL clients can specify the exact data they want through a standardized query language. It is also a good choice for APIs that aggregate data from multiple sources and then serve it to multiple clients.\\\n\\\nThe gRPC framework is a good fit when developing internal APIs with frequent interaction between microservices. It is commonly used for collecting data from low-level agents like different IoT devices. However, its limited browser support makes it difficult to use in customer-facing web applications.\\\n\"]],\"start1\":684,\"start2\":684,\"length1\":8,\"length2\":1118}]"
metadata_diff: {"new":{},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2022-12-14T17:04:55.520Z
created_time: 2022-12-14T17:04:55.520Z
type_: 13