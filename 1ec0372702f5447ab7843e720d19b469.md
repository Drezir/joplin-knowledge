id: 1ec0372702f5447ab7843e720d19b469
parent_id: 
item_type: 1
item_id: 84324716a99b4d40b9b4b8dcbb8e234a
item_updated_time: 1662392685032
title_diff: "[{\"diffs\":[[1,\"Local Variable Type Inference\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":29}]"
body_diff: "[{\"diffs\":[[1,\"# [Local Variable Type Inference](https://github.com/openjdk/amber-docs/blob/master/site/guides/lvti-style-guide.md)\\\n\\\n## Introduction\\\n\\\nJava SE 10 introduced [type inference for local variables][jep286]. Previously,\\\nall local variable declarations required an explicit (manifest) type\\\non the left-hand side. With type inference, the explicit type can be\\\nreplaced by the reserved type name `var` for local variable\\\ndeclarations that have initializers. The type of the variable is\\\ninferred from the type of the initializer.\\\n\\\nThere is a certain amount of controversy over this feature. Some\\\nwelcome the concision it enables; others fear that it deprives readers\\\nof important type information, impairing readability.  And both groups\\\nare right. It can make code more readable by eliminating redundant\\\ninformation, and it can also make code less readable by eliding useful\\\ninformation.  Another group worries that it will be overused,\\\nresulting in more bad Java code being written.  This is also true, but\\\nit's also likely to result in more *good* Java code being written.\\\nLike all features, it must be used with judgment.  There's no blanket\\\nrule for when it should and shouldn't be used.\\\n\\\nLocal variable declarations do not exist in isolation; the surrounding\\\ncode can affect or even overwhelm the effects of using `var`. The goal\\\nof this document is to examine the impact that surrounding code has on\\\n`var` declarations, to explain some of the tradeoffs, and to provide\\\nguidelines for the effective use of `var`.\\\n\\\n## Principles\\\n\\\n### P1. Reading code is more important than writing code. {#P1}\\\n\\\nCode is read much more often than it is written. Further, when writing\\\ncode, we usually have the whole context in our head, and take our\\\ntime; when reading code, we are often context-switching, and may be in\\\nmore of a hurry.  Whether and how particular language features are\\\nused ought to be determined by their impact on *future readers* of the\\\nprogram, not its original author. Shorter programs can be preferable\\\nto longer ones, but shortening a program too much can omit information\\\nthat's useful for understanding the program. The central issue here is\\\nto find the right size for the program such that understandability is\\\nmaximized.\\\n\\\nWe are specifically unconcerned here with the amount of keyboarding\\\nthat's necessary to input or to edit a program. While concision may be\\\na nice bonus for the author, focusing on it misses the main goal,\\\nwhich is to improve the understandability of the resulting program.\\\n\\\n### P2. Code should be clear from local reasoning. {#P2}\\\n\\\nThe reader should be able to look at a `var` declaration, along with\\\nuses of the declared variable, and understand almost immediately\\\nwhat's going on. Ideally, the code should be readily understandable\\\nusing only the context from a snippet or a patch. If understanding a\\\n`var` declaration requires the reader to look at several locations\\\naround the code, it might not be a good situation in which to use\\\n`var`. Then again, it might indicate a problem with the code itself.\\\n\\\n### P3. Code readability shouldn't depend on IDEs. {#P3}\\\n\\\nCode is often written and read within an IDE, so it's tempting to rely\\\nheavily on code analysis features of IDEs. For type declarations, why\\\nnot just use `var` everywhere, since one can always point at a\\\nvariable to determine its type?\\\n\\\nThere are two reasons. The first is that code is often read outside an\\\nIDE. Code appears in many places where IDE facilities aren't\\\navailable, such as snippets within a document, browsing a repository\\\non the internet, or in a patch file. It is counterproductive to have\\\nto import code into an IDE simply to understand what the code does.\\\n\\\nThe second reason is that even when one is reading code within an IDE,\\\nexplicit actions are often necessary to query the IDE for further\\\ninformation about a variable. For instance, to query the type of a\\\nvariable declared using `var`, one might have to hover the pointer\\\nover the variable and wait for a popup. This might take only a moment,\\\nbut it disrupts the flow of reading.\\\n\\\nCode should be self-revealing. It should be understandable on its\\\nface, without the need for assistance from tools.\\\n\\\n### P4. Explicit types are a tradeoff. {#P4}\\\n\\\nJava has historically required local variable declarations to include\\\nthe type explicitly. While explicit types can be very helpful, they\\\nare sometimes not very important, and are sometimes just in the\\\nway. Requiring an explicit type can add clutter that crowds out useful\\\ninformation.\\\n\\\nOmitting an explicit type can reduce clutter, but only if its omission\\\ndoesn't impair understandability. The type isn't the only way to\\\nconvey information to the reader. Other means include the variable's\\\nname and the initializer expression. We should take all the available\\\nchannels into account when determining whether it's OK to mute one of\\\nthese channels.\\\n\\\n## Guidelines\\\n\\\n### G1. Choose variable names that provide useful information. {#G1}\\\n\\\nThis is good practice in general, but it's much more\\\nimportant in the context of `var`. In a `var` declaration, information\\\nabout the meaning and use of the variable can be conveyed using the\\\nvariable's name. Replacing an explicit type with var should often be\\\naccompanied by improving the variable name.  For example:\\\n\\\n    // ORIGINAL\\\n    List<Customer> x = dbconn.executeQuery(query);\\\n\\\n    // GOOD\\\n    var custList = dbconn.executeQuery(query);\\\n\\\nIn this case, a useless variable name has been replaced with a name\\\nthat is evocative of the type of the variable, which is now implicit\\\nin the `var` declaration.\\\n\\\nEncoding the variable's type in its name, taken to its logical\\\nconclusion, results in \\\"[Hungarian Notation]\\\". Just as with explicit\\\ntypes, this is sometimes helpful, and sometimes just clutter.  In this\\\nexample the name `custList` implies that a `List` is being\\\nreturned. That might not be significant. Instead of the exact type,\\\nit's sometimes better for a variable's name to express the role or the\\\nnature of the variable, such as \\\"customers\\\":\\\n\\\n    // ORIGINAL\\\n    try (Stream<Customer> result = dbconn.executeQuery(query)) {\\\n        return result.map(...)\\\n                     .filter(...)\\\n                     .findAny();\\\n    }\\\n\\\n    // GOOD\\\n    try (var customers = dbconn.executeQuery(query)) {\\\n        return customers.map(...)\\\n                        .filter(...)\\\n                        .findAny();\\\n    }\\\n\\\n### G2. Minimize the scope of local variables. {#G2}\\\n\\\nLimiting the scope of local variables is good practice in\\\ngeneral. This practice is described in [*Effective Java (3rd Edition)*][Bloch],\\\nItem 57. It applies with extra force if `var` is in use.\\\n\\\nIn the following example, the `add` method clearly adds the special\\\nitem as the last list element, so it's processed last, as expected.\\\n\\\n    var items = new ArrayList<Item>(...);\\\n    items.add(MUST_BE_PROCESSED_LAST);\\\n    for (var item : items) ...\\\n\\\nNow suppose that in order to remove duplicate items, a programmer were\\\nto modify this code to use a `HashSet` instead of an `ArrayList`:\\\n\\\n    var items = new HashSet<Item>(...);\\\n    items.add(MUST_BE_PROCESSED_LAST);\\\n    for (var item : items) ...\\\n\\\nThis code now has a bug, since sets don't have a defined iteration\\\norder. However, the programmer is likely to fix this bug immediately,\\\nas the uses of the `items` variable are adjacent to its declaration.\\\n\\\nNow suppose that this code is part of a large method, with a\\\ncorrespondingly large scope for the `items` variable:\\\n\\\n    var items = new HashSet<Item>(...);\\\n\\\n    // ... 100 lines of code ...\\\n\\\n    items.add(MUST_BE_PROCESSED_LAST);\\\n    for (var item : items) ...\\\n\\\nThe impact of changing from an `ArrayList` to a `HashSet` is no longer\\\nreadily apparent, since `items` is used so far away from its\\\ndeclaration. It seems likely that this bug could survive for much\\\nlonger.\\\n\\\nIf `items` had been declared explicitly as `List<String>`, changing\\\nthe initializer would also require changing the type to\\\n`Set<String>`. This might prompt the programmer to inspect the rest of\\\nthe method for code that would be impacted by such a change. (Then\\\nagain, it might not.)  Use of `var` would remove this prompting,\\\npossibly increasing the risk of a bug being introduced in code like\\\nthis.\\\n\\\nThis might seem like an argument against using `var`, but it really\\\nisn't. The initial example that uses `var` is perfectly fine. The\\\nproblem only occurs when the variable's scope is large. Instead of\\\nsimply avoiding `var` in these cases, one should change the code to\\\nreduce the scope of the local variables, and only then declare them\\\nwith `var`.\\\n\\\n### G3. Consider `var` when the initializer provides sufficient information to the reader. {#G3}\\\n\\\nLocal variables are often initialized with constructors. The name of\\\nthe class being constructed is often repeated as the explicit type on\\\nthe left-hand side. If the type name is long, use of `var` provides\\\nconcision without loss of information:\\\n\\\n    // ORIGINAL\\\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\\\n\\\n    // GOOD\\\n    var outputStream = new ByteArrayOutputStream();\\\n\\\nIt's also reasonable to use `var` in cases where the initializer is a\\\nmethod call, such as a static factory method, instead of a\\\nconstructor, and when its name contains enough type information:\\\n\\\n    // ORIGINAL\\\n    BufferedReader reader = Files.newBufferedReader(...);\\\n    List<String> stringList = List.of(\\\"a\\\", \\\"b\\\", \\\"c\\\");\\\n\\\n    // GOOD\\\n    var reader = Files.newBufferedReader(...);\\\n    var stringList = List.of(\\\"a\\\", \\\"b\\\", \\\"c\\\");\\\n\\\nIn these cases, the methods' names strongly imply a particular return type, which is then used for inferring the type of the variable.\\\n\\\n### G4. Use `var` to break up chained or nested expressions with local variables. {#G4}\\\n\\\nConsider code that takes a collection of strings and finds the string\\\nthat occurs most often. This might look like the following:\\\n\\\n    return strings.stream()\\\n                  .collect(groupingBy(s -> s, counting()))\\\n                  .entrySet()\\\n                  .stream()\\\n                  .max(Map.Entry.comparingByValue())\\\n                  .map(Map.Entry::getKey);\\\n\\\nThis code is correct, but it's potentially confusing, as it looks like\\\na single stream pipeline. In fact, it's a short stream, followed by a\\\nsecond stream over the result of the first stream, followed by a\\\nmapping of the `Optional` result of the second stream. The most readable\\\nway to express this code would have been as two or three statements;\\\nfirst group entries into a map, then reduce over that map, then\\\nextract the key from the result (if present), as shown below:\\\n\\\n    Map<String, Long> freqMap = strings.stream()\\\n                                       .collect(groupingBy(s -> s, counting()));\\\n    Optional<Map.Entry<String, Long>> maxEntryOpt = freqMap.entrySet()\\\n                                                           .stream()\\\n                                                           .max(Map.Entry.comparingByValue());\\\n    return maxEntryOpt.map(Map.Entry::getKey);\\\n\\\nBut the author probably resisted doing that because writing the types\\\nof the intermediate variables seemed too burdensome, so instead they\\\ndistorted the control flow.  Using `var` allows us to express the\\\ncode more naturally without paying the high price of explicitly\\\ndeclaring the types of the intermediate variables:\\\n\\\n    var freqMap = strings.stream()\\\n                         .collect(groupingBy(s -> s, counting()));\\\n    var maxEntryOpt = freqMap.entrySet()\\\n                             .stream()\\\n                             .max(Map.Entry.comparingByValue());\\\n    return maxEntryOpt.map(Map.Entry::getKey);\\\n\\\nOne might legitimately prefer the first snippet with its single long\\\nchain of method calls. However, in some cases it's better to break up\\\nlong method chains. Using `var` for these cases is a viable approach,\\\nwhereas using full declarations of the intermediate variables in the\\\nsecond snippet makes it an unpalatable alternative.  As with many\\\nother situations, the correct use of `var` might involve both taking\\\nsomething out (explicit types) and adding something back (better\\\nvariable names, better structuring of code).\\\n\\\n### G5. Don't worry too much about \\\"programming to the interface\\\" with local variables. {#G5}\\\n\\\nA common idiom in Java programming is to construct an instance of a\\\nconcrete type but to assign it to a variable of an interface\\\ntype. This binds the code to the abstraction instead of the\\\nimplementation, which preserves flexibility during future maintenance\\\nof the code. For example:\\\n\\\n    // ORIGINAL\\\n    List<String> list = new ArrayList<>();\\\n\\\nIf `var` is used, however, the concrete type is inferred instead of the interface:\\\n\\\n    // Inferred type of list is ArrayList<String>\\\n    var list = new ArrayList<String>();\\\n\\\nIt must be reiterated here that `var` can *only* be used for local\\\nvariables. It cannot be used to infer field types, method parameter\\\ntypes, and method return types. The principle of \\\"programming to the\\\ninterface\\\" is still as important as ever in those contexts.\\\n\\\nThe main issue is that code that uses the variable can form\\\ndependencies on the concrete implementation. If the variable's\\\ninitializer were to change in the future, this might cause its\\\ninferred type to change, causing errors or bugs to occur in subsequent\\\ncode that uses the variable.\\\n\\\nIf, as recommended in guideline G2, the scope of the local variable is\\\nsmall, the risks from \\\"leakage\\\" of the concrete implementation that\\\ncan impact the subsequent code are limited. If the variable is used\\\nonly in code that's a few lines away, it should be easy to avoid\\\nproblems or to mitigate them if they arise.\\\n\\\nIn this particular case, `ArrayList` only contains a couple of methods\\\nthat aren't on `List`, namely `ensureCapacity` and `trimToSize`. These\\\nmethods don't affect the contents of the list, so calls to them don't\\\naffect the correctness of the program. This further reduces the impact\\\nof the inferred type being a concrete implementation rather than an\\\ninterface.\\\n\\\n### G6. Take care when using `var` with diamond or generic methods. {#G6}\\\n\\\nBoth `var` and the \\\"diamond\\\" feature allow you to omit explicit type\\\ninformation when it can be derived from information already\\\npresent. Can you use both in the same declaration?\\\n\\\nConsider the following:\\\n\\\n    PriorityQueue<Item> itemQueue = new PriorityQueue<Item>();\\\n\\\nThis can be rewritten using either diamond or `var`, without losing\\\ntype information:\\\n\\\n    // OK: both declare variables of type PriorityQueue<Item>\\\n    PriorityQueue<Item> itemQueue = new PriorityQueue<>();\\\n    var itemQueue = new PriorityQueue<Item>();\\\n\\\nIt is legal to use both `var` and diamond, but the inferred type will\\\nchange:\\\n\\\n    // DANGEROUS: infers as PriorityQueue<Object>\\\n    var itemQueue = new PriorityQueue<>();\\\n\\\nFor its inference, diamond can use the target type (typically, the\\\nleft-hand side of a declaration) or the types of constructor\\\narguments. If neither is present, it falls back to the broadest\\\napplicable type, which is often `Object`. This is usually not what was\\\nintended.\\\n\\\nGeneric methods have employed type inference so successfully that it's\\\nquite rare for programmers to provide explicit type arguments.\\\nInference for generic methods relies on the target type if there are\\\nno actual method arguments that provide sufficient type\\\ninformation. In a `var` declaration, there is no target type, so a\\\nsimilar issue can occur as with diamond. For example,\\\n\\\n    // DANGEROUS: infers as List<Object>\\\n    var list = List.of();\\\n\\\nWith both diamond and generic methods, additional type information can\\\nbe provided by actual arguments to the constructor or method, allowing\\\nthe intended type to be inferred. Thus,\\\n\\\n    // OK: itemQueue infers as PriorityQueue<String>\\\n    Comparator<String> comp = ... ;\\\n    var itemQueue = new PriorityQueue<>(comp);\\\n\\\n    // OK: infers as List<BigInteger>\\\n    var list = List.of(BigInteger.ZERO);\\\n\\\nIf you decide to use `var` with diamond or a generic method, you\\\nshould ensure that method or constructor arguments provide enough type\\\ninformation so that the inferred type matches your intent. Otherwise,\\\navoid using both `var` with diamond or a generic method in the same\\\ndeclaration.\\\n\\\n### G7. Take care when using `var` with literals. {#G7}\\\n\\\nPrimitive literals can be used as initializers for `var`\\\ndeclarations. It's unlikely that using `var` in these cases will\\\nprovide much advantage, as the type names are generally short.\\\nHowever, `var` is sometimes useful, for example, to align variable\\\nnames.\\\n\\\nThere is no issue with boolean, character, `long`, and string\\\nliterals. The type inferred from these literals is precise, and so the\\\nmeaning of `var` is unambiguous:\\\n\\\n    // ORIGINAL\\\n    boolean ready = true;\\\n    char ch = '\\\\ufffd';\\\n    long sum = 0L;\\\n    String label = \\\"wombat\\\";\\\n\\\n    // GOOD\\\n    var ready = true;\\\n    var ch    = '\\\\ufffd';\\\n    var sum   = 0L;\\\n    var label = \\\"wombat\\\";\\\n\\\nParticular care should be taken when the initializer is a numeric value,\\\nespecially an integer literal. With an explicit type on the left-hand\\\nside, the numeric value may be silently widened or narrowed to types\\\nother than `int`. With `var`, the value will be inferred as an\\\n`int`, which may be unintended.\\\n\\\n    // ORIGINAL\\\n    byte flags = 0;\\\n    short mask = 0x7fff;\\\n    long base = 17;\\\n\\\n    // DANGEROUS: all infer as int\\\n    var flags = 0;\\\n    var mask = 0x7fff;\\\n    var base = 17;\\\n\\\nFloating point literals are mostly unambiguous:\\\n\\\n    // ORIGINAL\\\n    float f = 1.0f;\\\n    double d = 2.0;\\\n\\\n    // GOOD\\\n    var f = 1.0f;\\\n    var d = 2.0;\\\n\\\nNote that `float` literals can be widened silently to `double`. It is\\\nsomewhat obtuse to initialize a `double` variable using an explicit\\\n`float` literal such as `3.0f`, however, cases may arise where a\\\n`double` variable is initialized from a `float` field. Caution with\\\n`var` is advised here:\\\n\\\n    // ORIGINAL\\\n    static final float INITIAL = 3.0f;\\\n    ...\\\n    double temp = INITIAL;\\\n\\\n    // DANGEROUS: now infers as float\\\n    var temp = INITIAL;\\\n\\\n(Indeed, this example violates guideline G3, because there\\\nisn't enough information in the initializer for a reader to see\\\nthe inferred type.)\\\n\\\n## Examples\\\n\\\nThis section contains some examples of where `var` can be used to\\\ngreatest benefit.\\\n\\\nThe following code removes at most `max` matching entries from a\\\nMap. Wildcarded type bounds are used for improving the flexibility of\\\nthe method, resulting in considerable verbosity. Unfortunately, this\\\nrequires the type of the Iterator to be a nested wildcard, making its\\\ndeclaration more verbose. This declaration is so long that the header\\\nof the for-loop no longer fits on a single line, making the code even\\\nharder to read.\\\n\\\n    // ORIGINAL\\\n    void removeMatches(Map<? extends String, ? extends Number> map, int max) {\\\n        for (Iterator<? extends Map.Entry<? extends String, ? extends Number>> iterator =\\\n                 map.entrySet().iterator(); iterator.hasNext();) {\\\n            Map.Entry<? extends String, ? extends Number> entry = iterator.next();\\\n            if (max > 0 && matches(entry)) {\\\n                iterator.remove();\\\n                max--;\\\n            }\\\n        }\\\n    }\\\n\\\nUse of `var` here removes the noisy type declarations for the local\\\nvariables. Having explicit types for the Iterator and Map.Entry locals\\\nin this kind of loop is largely unnecessary. This also allows the\\\nfor-loop control to fit on a single line, further improving\\\nreadability.\\\n\\\n    // GOOD\\\n    void removeMatches(Map<? extends String, ? extends Number> map, int max) {\\\n        for (var iterator = map.entrySet().iterator(); iterator.hasNext();) {\\\n            var entry = iterator.next();\\\n            if (max > 0 && matches(entry)) {\\\n                iterator.remove();\\\n                max--;\\\n            }\\\n        }\\\n    }\\\n\\\nConsider code that reads a single line of text from a socket using\\\nthe try-with-resources statement. The networking and I/O APIs use an\\\nobject wrapping idiom. Each intermediate object must be declared as a\\\nresource variable so that it will be closed properly if an error\\\noccurs while opening a subsequent wrapper. The conventional code for\\\nthis requires the class name to be repeated on the left and right\\\nsides of the variable declaration, resulting in a lot of clutter:\\\n\\\n    // ORIGINAL\\\n    try (InputStream is = socket.getInputStream();\\\n         InputStreamReader isr = new InputStreamReader(is, charsetName);\\\n         BufferedReader buf = new BufferedReader(isr)) {\\\n        return buf.readLine();\\\n    }\\\n\\\nUsing `var` reduces the noise considerably:\\\n\\\n    // GOOD\\\n    try (var inputStream = socket.getInputStream();\\\n         var reader = new InputStreamReader(inputStream, charsetName);\\\n         var bufReader = new BufferedReader(reader)) {\\\n        return bufReader.readLine();\\\n    }\\\n\\\n## Conclusion\\\n\\\nUsing `var` for declarations can improve code by reducing clutter,\\\nthereby letting more important information stand out. On the other\\\nhand, applying `var` indiscriminately can make things worse. Used\\\nproperly, `var` can help improve good code, making it shorter and\\\nclearer without compromising understandability.\\\n\\\n\\\n[jep286]: https://openjdk.java.net/jeps/286\\\n[Hungarian Notation]: https://en.wikipedia.org/wiki/Hungarian_notation\\\n[Bloch]: https://www.pearson.com/us/higher-education/program/Bloch-Effective-Java-3rd-Edition/PGM1763855.html\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":21238}]"
metadata_diff: {"new":{"id":"84324716a99b4d40b9b4b8dcbb8e234a","parent_id":"4e9653fd9f084b119fc1746b2ef5a6a9","latitude":"50.03430920","longitude":"15.78119940","altitude":"0.0000","author":"","source_url":"","is_todo":0,"todo_due":0,"todo_completed":0,"source":"joplin-desktop","source_application":"net.cozic.joplin-desktop","application_data":"","order":0,"markup_language":1,"is_shared":0,"share_id":"","conflict_original_id":"","master_key_id":""},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2022-09-05T15:49:20.785Z
created_time: 2022-09-05T15:49:20.785Z
type_: 13